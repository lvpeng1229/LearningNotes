#### 目录介绍
- 01.三大特点
    - 1.1 封装
    - 1.2 继承
    - 1.3 多态
    - 1.4 抽象
- 02.六大原则
    - 2.1 单一职责原则
    - 2.2 开放封闭原则
    - 2.3 替换原则
    - 2.4 依赖原则
    - 2.5 接口分离原则
    - 2.6 迪米特法则
- 03.实践案例分析
    - 3.1 修改代码拓展性



### 01.三大特点
#### 1.1 封装
- 将对象的属性和实现细节隐藏起来，只提供公共的访问方式。
- 好处：
    - a。将外界的变化隔离开，使程序具备独立，安全和稳定性。
    - b。便于设计者使用，提高了代码的复用性
- 方式：
    - 将某一功能，属性抽离出来，独立写成单独的方法或类。
    - 设置访问权限可以限定该功能或属性可以被特定的访问者访问，保证了程序的安全性和功能的稳定性。


#### 1.2 继承
- 继承是从已有的类派生出新的类，新的类能继承已有类的数据属性和行为，并扩展新的功能。
- 作用：
    - a。父类具备的方法子类可直接继承过来，不用重新书写，提高了代码的复用性
    - b。让类与类之间产生了关系，有了关系才有了多态的实现。
    - c。java支持单继承，译为多继承存在安全隐患（当多个父类存在相同功能时，子类不确定要运行那个），java支持多层继承，即父类还可以继承其他的类。java用另外一种机制解决了单继承的问题，即多实现。


#### 1.3 多态
- 允许不同类型的子对象对统一消息做出不同的响应。
- java中多态的表现形式：
    - a。父类引用指向子类对象
    - b。父类引用几首自己的子类对象



#### 1.4 抽象
- Java关于抽象，最常被讨论的就是abstract类和interfaces
- 抽象是把系统中需要处理的数据和在这些数据上的操作结合在一起，根据功能、性质和用途等因素抽象成不同的抽象数据类型。每个抽象数据类型既包含了数据，又包含了针对这些数据的授权操作。在面向对象的程序设计中，抽象数据类型是用“类”这种结构来实现的。





### 02.六大原则
#### 2.1 单一职责原则
- 指一个类的功能要单一，不能包罗万象。


#### 2.2 开放封闭原则
- 指一个模块在扩展性方面应是开放的，在更改性方面应是封闭的


#### 2.3 替换原则
- 子类应当可以替换父类，并出现在父类能够出现的任何位置


#### 2.4 依赖原则
- 具体依赖抽象，上层依赖下层


#### 2.5 接口分离原则
- 模块间要通过抽象接口隔开，而不是通过具体的类强行耦合起来。


#### 2.6 迪米特法则
- 又称最少知道原则（Demeter Principle，DP）
    - 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。





### 03.实践案例分析
#### 3.1 将不同对象分类的服务方法进行抽象，把业务逻辑的紧耦合关系拆开，实现代码的隔离保证了方便的扩展？
- 看看下面这段代码，改编某伟大公司产品代码，你觉得可以利用面向对象设计原则如何改进？
    ```
    public class VIPCenter {
        void serviceVIP(T extend User user>) {
         if (user instanceof SlumDogVIP) {
            // 穷 X VIP，活动抢的那种
            // do somthing
          } else if(user instanceof RealVIP) {
            // do somthing
          }
          // ...
    }
    ```
    - 这段代码的一个问题是，业务逻辑集中在一起，当出现新的用户类型时，比如，大数据发现了我们是肥羊，需要去收获一下， 这就需要直接去修改服务方法代码实现，这可能会意外影响不相关的某个用户类型逻辑。
    - 利用开关原则，可以尝试改造为下面的代码。将不同对象分类的服务方法进行抽象，把业务逻辑的紧耦合关系拆开，实现代码的隔离保证了方便的扩展。[技术博客大总结](https://github.com/yangchong211/YCBlogs)
    ```
    public class VIPCenter {
        private Map<User.TYPE, ServiceProvider> providers;
        void serviceVIP(T extend User user） {
            providers.get(user.getType()).service(user);
        }
    }
    
    interface ServiceProvider{
        void service(T extend User user) ;
    }
    
    class SlumDogVIPServiceProvider implements ServiceProvider{
        void service(T extend User user){
            // do somthing
        }
    }
    
    class RealVIPServiceProvider implements ServiceProvider{
        void service(T extend User user) {
            // do something
        }
    }
    ```

